/**
 *
 * Creates a new TransactionService. Generally you should never create a PAYMILL service on your own. Instead use the exported "transactions".
 * @class TransactionService
 */
function TransactionService() {

}

TransactionService.prototype = new PaymillService();
TransactionService.prototype.constructor = TransactionService;
TransactionService.prototype.getPaymillObject = function() {
	return Transaction;
};
TransactionService.prototype.getEndpointPath = function() {
	return "/transactions";
};

TransactionService.prototype._createTransaction = function(map, amount, currency, description, client, fee_amount, fee_payment, fee_currency, cb) {
	validateNumber(amount,"amount",false);
    validateString(currency,"currency",false);
	map.amount = amount;
	map.currency = currency;
	map.description = description;
	try {
		var clientId = getIdFromObject(client, Client);
		map.client = clientId;
	} catch (e) {
		// no client
	}
	if (fee_amount) {
		map.fee_amount = fee_amount;
	}
	if (fee_payment) {
		map.fee_payment = fee_payment;
	}
	if (fee_currency) {
		map.fee_currency = fee_currency;
	}
	map.source = getSourceIdentifier();
	return this._create(map, Transaction, cb);
};

/**
 * Create a transaction with a token.
 * @param {string} token the payment token, generated by the PAYMILL bridge.
 * @param {(string|number)} amount amount (in cents) which will be charged.
 * @param {string} currency ISO 4217 formatted currency code.
 * @param {string} description A short description for the transaction.
 * @param {(string|Client)} [client] the identifier of a client or a client.
 * @param {(number|string)} fee_amount Fee included in the transaction amount (set by a connected app). Mandatory if fee_payment is set.
 * @param {string} fee_payment the identifier of the payment from which the fee will be charged (creditcard-object or directdebit-object). Mandatory if fee_amount is set.
 * @param {string} fee_currency ISO 4217 formatted currency code. If not set, the currency of the transaction is used.
 * @param {Object} [cb] a callback.
 * @return {Promise} a promise, which will be fulfilled with a Transaction or rejected with a PMError.
 * @memberOf TransactionService
 */
TransactionService.prototype.createWithToken = function(token, amount, currency, description, client, fee_amount, fee_payment, fee_currency, cb) {
	try {
		validateString(token,"token",false);
		var map = {
			"token" : token
		};
		return this._createTransaction(map, amount, currency, description, client, fee_amount, fee_payment, fee_currency, cb);
	} catch(e) {
		return this._reject(e);
	}
};
/**
 * Create a transaction with a payment object.
 * @param {(string|Payment)} payment the payment object for the transaction or its id.
 * @param {(string|number)} amount amount (in cents) which will be charged.
 * @param {string} currency ISO 4217 formatted currency code.
 * @param {string} description A short description for the transaction.
 * @param {(string|Client)} [client] the identifier of a client or a client. When this parameter is used, you have also to specify a payment method which is not assigned to a client yet. If you attempt to use this parameter when creating a transaction and when specifying a token or preauthorization, the specified client will be ignored.
 * @param {(number|string)} fee_amount Fee included in the transaction amount (set by a connected app). Mandatory if fee_payment is set.
 * @param {string} fee_payment the identifier of the payment from which the fee will be charged (creditcard-object or directdebit-object). Mandatory if fee_amount is set.
 * @param {string} fee_currency ISO 4217 formatted currency code. If not set, the currency of the transaction is used.
 * @param {Object} [cb] a callback.
 * @return {Promise} a promise, which will be fulfilled with a Transaction or rejected with a PMError.
 * @memberOf TransactionService
 */
TransactionService.prototype.createWithPayment = function(payment, amount, currency, description, client, fee_amount, fee_payment, fee_currency, cb) {
	try {
		var id = getIdFromObject(payment, Payment);
		var map = {
			"payment" : id
		};
		return this._createTransaction(map, amount, currency, description, client, fee_amount, fee_payment, cb);
	} catch(e) {
		return this._reject(e);
	}
};
/**
 * Create a transaction with a payment object.
 * @param {(string|Preauthorization)} preauthroization the preauthroization object for the transaction or its id.
 * @param {(string|number)} amount amount (in cents) which will be charged.
 * @param {string} currency ISO 4217 formatted currency code.
 * @param {string} description A short description for the transaction.
 * @param {(string|Client)} [client] the identifier of a client or a client. When this parameter is used, you have also to specify a payment method which is not assigned to a client yet. If you attempt to use this parameter when creating a transaction and when specifying a token or preauthorization, the specified client will be ignored.
 * @param {(number|string)} fee_amount Fee included in the transaction amount (set by a connected app). Mandatory if fee_payment is set.
 * @param {string} fee_payment the identifier of the payment from which the fee will be charged (creditcard-object or directdebit-object). Mandatory if fee_amount is set.
 * @param {string} fee_currency ISO 4217 formatted currency code. If not set, the currency of the transaction is used.
 * @param {Object} [cb] a callback.
 * @return {Promise} a promise, which will be fulfilled with a Transaction or rejected with a PMError.
 * @memberOf TransactionService
 */
TransactionService.prototype.createWithPreauthorization = function(preauthroization, amount, currency, description, client, fee_amount, fee_payment, fee_currency, cb) {
	try {
		var id = getIdFromObject(preauthroization, Preauthorization);
		var map = {
			"preauthorization" : id
		};
		return this._createTransaction(map, amount, currency, description, client, fee_amount, fee_payment, cb);
	} catch(e) {
		return this._reject(e);
	}
};

/**
 * This function refunds a transaction that has been created previously and was refunded in parts or wasn't refunded at all. The inserted amount will be refunded to the credit card / direct debit of the original transaction. There will be some fees for the merchant for every refund.
 * @param {(string|Transaction)} transaction the transaction object or its id.
 * @param {(string|number)} amount amount (in cents) which will be charged.
 * @param {string} description additional description for this refund
 * @param {Object} [cb] a callback.
 * @return {Promise} a promise, which will be fulfilled with a Refund or rejected with a PMError.
 * @memberOf TransactionService
 */
TransactionService.prototype.refund = function(transaction, amount, description, cb) {
	try {
		validateNumber(amount,"amount",false);
		var id = getIdFromObject(transaction, Transaction);
		var map = {
			"amount" : amount
		};
		if (description) {
			map.description = description;
		}
		var result = new Refund();
		var httpRequest = new HttpRequest("/refunds/" + id, "POST", map);
		return this._request(httpRequest, function(httpData) {
			var allData = JSON.parse(httpData);
			result.fromJson(allData.data);
			return result;
		}, cb);
	} catch(e) {
		return this._reject(e, cb);
	}
};
/**
 * List transactions.
 * @param {(string|number)} [count] limit of objects to be listed. use for pagination.
 * @param {(string|number)} [offset] offset. use for pagination.
 * @param {(Transaction.Filter|null)} [filter] a list filter or null.
 * @param {(Transaction.Order|null)} [order] a list order or null.
 * @param {Object} [cb] a callback.
 * @return {Promise} a promise, which will be fulfilled with a PayMillObjectList or rejected with a PMError.
 * @memberOf TransactionService
 */
TransactionService.prototype.list = function(count, offset, filter, order, cb) {
	return this._list(count, offset, filter, order, cb);
};

/**
 * Remove a transaction.
 * @param {Transaction} obj a transaction object or its id.
 * @param {Object} [cb] a callback.
 * @return {Promise} a promise, which will be fulfilled with a Transaction or rejected with a PMError.
 * @memberOf TransactionService
 */
TransactionService.prototype.remove = function(obj, cb) {
	return this._remove(obj, cb);
};

/**
 * Update a transaction.
 * @param {Transaction} obj a transaction object or its id.Note, if you specify an object, the same object will be updated and returned!
 * @param {Object} [cb] a callback.
 * @return {Promise} a promise, which will be fulfilled with a Transaction or rejected with a PMError.
 * @memberOf TransactionService
 */
TransactionService.prototype.update = function(obj, cb) {
	return this._update(obj, cb);
};

/**
 * Get a transaction.
 * @param {(string|Transaction)} obj a transaction object or its id. note, if you set a transaction object it will be updated, no new object will be created.
 * @param {Object} [cb] a callback.
 * @return {Promise} a promise, which will be fulfilled with a Transaction or rejected with a PMError.
 * @memberOf TransactionService
 */
TransactionService.prototype.detail = function(obj, cb) {
	return this._detail(obj, cb);
};


/**
 * Create a transaction with a token. Chain further values by calling withXXX()
 * functions and finish by calling create().
 * @param {string} token the payment token, generated by the PAYMILL bridge.
 * @param {(string|number)} amount amount (in cents) which will be charged.
 * @param {string} currency ISO 4217 formatted currency code.
 * @return {TransactionService.Creator} a creator. when configured, please call create()
 * @memberOf TransactionService
 */
TransactionService.prototype.fromToken = function(token, amount, currency) {
    var creator = new TransactionService.Creator(this);
		validateString(token,"token",false);
		creator.map.token = token;

		validateNumber(amount,"amount",false);
		validateString(currency,"currency",false);
		creator.map.amount = amount;
		creator.map.currency = currency;
		creator.map.description = "";

    return creator;
};

/**
 * Create a transaction with a preauthorization. Chain further values by calling withXXX()
 * functions and finish by calling create().
 * @param {(string|Preauthorization)} preauth the preauthroization object for the transaction or its id.
 * @param {(string|number)} amount amount (in cents) which will be charged.
 * @param {string} currency ISO 4217 formatted currency code.
 * @return {TransactionService.Creator} a creator. when configured, please call create()
 * @memberOf TransactionService
 */
TransactionService.prototype.fromPreauth = function(preauth, amount, currency) {
    var creator = new TransactionService.Creator(this);
		creator.map.preauthorization = getIdFromObject(preauth,Preauthorization);

		validateNumber(amount,"amount",false);
		validateString(currency,"currency",false);
		creator.map.amount = amount;
		creator.map.currency = currency;
		creator.map.description = "";

    return creator;
};

/**
 * Create a transaction with a preauthorization. Chain further values by calling withXXX()
 * functions and finish by calling create().
 * @param {(string|Payment)} payment the payment object for the transaction or its id
 * @param {(string|number)} amount amount (in cents) which will be charged.
 * @param {string} currency ISO 4217 formatted currency code.
 * @return {TransactionService.Creator} a creator. when configured, please call create()
 * @memberOf TransactionService
 */
TransactionService.prototype.fromPayment = function(payment, amount, currency) {
    var creator = new TransactionService.Creator(this);
		creator.map.payment = getIdFromObject(payment, Payment);

		validateNumber(amount,"amount",false);
		validateString(currency,"currency",false);
		creator.map.amount = amount;
		creator.map.currency = currency;
		creator.map.description = "";

    return creator;
};

/**
 * A helper for the complex creation method
 * @class TransactionService.Creator
 * @memberof TransactionService
 */
TransactionService.Creator = function(service) {
    this.service = service;
		this.map = {};
};

/**
 * Create a transaction with this creator.
 * @return {Promise} a promise, which will be fulfilled with a Transaction or rejected with a PMError.
 * @memberOf TransactionService.Creator
 */
TransactionService.Creator.prototype.create = function(cb) {
	return this.service._create(this.map, Transaction, cb);
};

/**
 * Add a description
 * @param {string} description
 * @return {TransactionService.Creator} the same creator
 * @memberOf TransactionService.Creator
 */
TransactionService.Creator.prototype.withDescription = function(description) {
		validateString(description);
    this.map.description = description;
    return this;
};

/**
 * Add a client
 * @param {(string|Client)} client
 * @return {TransactionService.Creator} the same creator
 * @memberOf TransactionService.Creator
 */
TransactionService.Creator.prototype.withClient = function(client) {
    this.map.client = getIdFromObject(client);
    return this;
};

/**
 * Add a fee amount
 * @param {(string|Client)} fee_amount
 * @return {TransactionService.Creator} the same creator
 * @memberOf TransactionService.Creator
 */
TransactionService.Creator.prototype.withFeeAmount = function(fee_amount) {
		validateNumber(fee_amount);
    this.map.fee_amount = fee_amount;
    return this;
};

/**
 * Add a fee payment
 * @param {(string|Client)} client
 * @return {TransactionService.Creator} the same creator
 * @memberOf TransactionService.Creator
 */
TransactionService.Creator.prototype.withFeePayment = function(fee_payment) {
    this.map.fee_payment = getIdFromObject(fee_payment);
    return this;
};

/**
 * Add a fee currency
 * @param {string} fee_currency
 * @return {TransactionService.Creator} the same creator
 * @memberOf TransactionService.Creator
 */
TransactionService.Creator.prototype.withFeeCurrency = function(fee_currency) {
    validateString(fee_currency,"fee_currency",false);
    this.map.fee_currency = fee_currency;
    return this;
};

/**
 * Add a mandate reference
 * @param {string} mandate_reference
 * @return {TransactionService.Creator} the same creator
 * @memberOf TransactionService.Creator
 */
TransactionService.Creator.prototype.withMandateReference = function(mandate_reference) {
    validateString(mandate_reference,"mandate_reference",false);
    this.map.mandate_reference = mandate_reference;
    return this;
};
