<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: paymill.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: paymill.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>/**
 * A Javascript wrapper for the PAYMILL Rest API.
 * @module Paymill
 *
 */"use strict";

var inited = false;
var privateKey;
var apiHost = "api.paymill.com";
var apiBaseUrl = "/v2";
var apiEncoding = "utf8";
var type;
var includeSnakeCase = true;
var httpClient;
var when;
var __;
function HttpClient() {

}

/**
 * Make a single http request.
 * @param {HttpRequest} httpRequest a http request object, describing all properties of the request
 * @param {object} callback the http callback containing error(PMerror) and success(rawTextData)
 * @abstract
 * @return {boolean}
 */
HttpClient.prototype.request = function(httpRequest, callback) {
	throw new PMError(PMError.Type.INTERNAL, "HttpClient.request() is abstract! Did you initialze?");
};
/**
 * Callback for HttpClient requests.
 * @callback HttpClient~requestCallback
 * @param {PMError} error a PMError for failure
 * @param {string} responseMessage
 */

function HttpRequest(path, method, params) {
	this.path = path;
	this.method = method;
	this.requestBody = null;
	this.headers = {};
	if (method == "GET" || method == "DELETE") {
		this.path += urlEncode(params, true);
	} else {
		if (params !== null) {
			this.requestBody = urlEncode(params, false);
			this.headers = {
				"Content-Type" : "application/x-www-form-urlencoded",
				"Content-Length" : this.requestBody.length
			};
		}
	}
}

function urlEncode(params, appendQuestion) {
	var ret = [];
	for (var key in params) {
		if (key === "") {
			continue;
		}
		ret.push(key + "=" + encodeURIComponent(params[key]));
	}
	if (ret.length > 0) {
		var result = ret.join("&");
		if (appendQuestion) {
			return "?" + result;
		} else {
			return result;
		}

	} else {
		return "";
	}
}

function NodeHttpClient(httpsLib) {
	this.https = httpsLib;
}

NodeHttpClient.prototype.request = function(httpRequest, callback) {

	var options = {
		hostname : apiHost,
		port : 443,
		path : apiBaseUrl + httpRequest.path,
		auth : privateKey + ":",
		method : httpRequest.method,
		headers : httpRequest.headers
	};
	var req = this.https.request(options, function(res) {
		res.setEncoding(apiEncoding);
		var status = res.statusCode;
		var headers = res.headers;
		var data = "";
		res.on("data", function(d) {
			data = data + d;
		});
		res.on("end", function() {
			if (status != 200) {
				callback.error(new PMError(PMError.Type.API, data, "http status code:" + status + "\nheaders:" + headers + "\ndata:" + data));
			} else {
				callback.success(data);
			}
		});

	});

	req.on("error", function(e) {
		callback.error(new PMError(PMError.Type.IO, null, e.toString()));
	});
	if ( typeof httpRequest.requestBody === "string" && httpRequest.requestBody.length > 0) {
		req.write(httpRequest.requestBody);
	}
	req.end();
};
function PMError(type, message, detailMessage) {
	if (message && message.length > 0) {
		this.message = type + ":" + message;
	} else {
		this.message = type + ".";
	}
	this.detailMessage = detailMessage;
	this.type = type;
}

PMError.prototype = new Error();
PMError.prototype.constructor = PMError;
PMError.prototype.name = "PMError";
PMError.Type = {
	API : "API Error",
	WRONG_PARAMS : "Invalid arguments",
	IO : "Network issue",
	NOT_INIT : "Not initialized",
	INTERNAL : "Internal error"
};
var Type = {
	Parse : 1,
	Nodejs : 2
};
function AbstractService() {

}

function includeCallbackInPromise(promise, callback) {
	var positive, negative;
	if (type === Type.Parse) {
		if (__.isFunction(callback.success)) {
			positive = callback.success;
		}
		if (__.isFunction(callback.error)) {
			negative = callback.error;
		}

	} else if (type === Type.Nodejs) {

		if (__.isFunction(callback)) {
			positive = function(result) {
				callback(null, result);
			};
			negative = function(error) {
				callback(error);
			};
		}
	} else {
		return;
	}
	if (positive !== undefined || negative !== undefined) {
		promise.then(positive, negative);
	}
}

function isFunction(object) {
	return !!(object && object.constructor && object.call && object.apply);
}

function getDefer() {
	if (type === Type.Parse) {
		return new Parse.Promise();
	} else if (type === Type.Nodejs) {
		return when.defer();
	}
}

function getPromise(defer) {
	if (type === Type.Parse) {
		return defer;
	} else if (type === Type.Nodejs) {
		return defer.promise;
	}
}

function TransactionService() {
	this.detail = function(id, cb) {
		var defer = getDefer();
		var promise = getPromise(defer);
		includeCallbackInPromise(promise, cb);
		var _id;
		try {
			_id = getIdFromObject(id, Transaction);
		} catch(e) {
			defer.reject(e);
			return promise;
		}
		httpClient.request(new HttpRequest("/transactions/" + id, "GET"), createErrorCallback(defer, function(httpData) {
			var allData = JSON.parse(httpData);
			defer.resolve(allData.data);
		}));
		return promise;
	};
}

function createErrorCallback(defer, successFunction) {
	var obj = {
		error : function(error) {
			defer(error);
		},
		success : successFunction
	};
	return obj;
}

/**
 *
 * @param {(PayMillObject|string)} obj either a string or a PayMillObject from objectType
 * @param {Object} objectType
 * @returns {string} the id
 * @throws {PMError} if param is not a string or not a valid object of the correct type with a string field id
 */
function getIdFromObject(obj, objectType) {
	if (__.isString(obj) && !__.isEmpty(obj)) {
		return obj;
	}
	if ( obj instanceof objectType && __.isString(obj.id)) {
		return obj;
	}
	throw new PMError(PMError.Type.WRONG_PARAMS, obj + "must be either a string or " + objectType + " with a valid id.");
}

TransactionService.prototype = new AbstractService();
TransactionService.prototype.constructor = TransactionService;
function PaymillObject() {

}

PaymillObject.prototype.originalJson = null;
PaymillObject.prototype.fromJson = function() {

};
function Transaction(id) {

}

Transaction.prototype.id = null;
Transaction.prototype = new PaymillObject();
Transaction.prototype.constructor = Transaction;

var transactions = new TransactionService();
exports.initialize = function(apiKey, config, includeSnakeCase) {
	//TODO fix initalization. do we need only enum for type, or also a config object???
	if ( typeof apiKey === "string") {

		privateKey = apiKey;
		inited = true;
	} else {
		throw new Error("An apiKey (string) must be specified.");
	}
	if ( typeof type === "string") {

	} else {
		var https = require("https");
		httpClient = new NodeHttpClient(https);
		when = require("when");
		type = Type.Nodejs;
		__ = require("underscore");
	}
	includeSnakeCase = includeSnakeCase;
};
exports.transactions = transactions;
exports.Transaction = Transaction;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Modules</h3><ul><li><a href="module-Paymill.html">Paymill</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-dev</a> on Mon Oct 07 2013 08:15:01 GMT+0200 (CEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
